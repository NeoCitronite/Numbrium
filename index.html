<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Zero-Sum Swap Puzzle (Canvas)</title>
  <style>
    :root{
      --bg: #0b1020;
      --text: rgba(255,255,255,.92);
      --muted: rgba(255,255,255,.70);
      --stroke: rgba(255,255,255,.16);
      --panel: rgba(255,255,255,.08);
      --accent: rgba(120,200,255,.85);
    }
    *{ box-sizing:border-box; }
    body{
      margin:0;
      min-height:100vh;
      background:
        radial-gradient(1000px 700px at 30% 20%, #1b2a6b 0%, transparent 55%),
        radial-gradient(900px 650px at 70% 70%, #5a1c5f 0%, transparent 55%),
        var(--bg);
      color: var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }
    .app{
      min-height:100vh;
      display:flex;
      flex-direction:column;
      padding: 12px;
      gap: 10px;
    }
    header{
      display:flex;
      flex-direction:column;
      gap: 10px;
    }
    .top{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap: 10px;
      flex-wrap:wrap;
    }
    .title h1{
      margin:0;
      font-size:18px;
      letter-spacing:.2px;
    }
    .title p{
      margin:4px 0 0;
      font-size:13px;
      color: var(--muted);
      line-height:1.25;
    }
    .controls{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      justify-content:flex-end;
      align-items:center;
    }
    button{
      appearance:none;
      border: 1px solid var(--stroke);
      background: rgba(255,255,255,.08);
      color: var(--text);
      padding: 10px 12px;
      border-radius: 14px;
      cursor:pointer;
      font-weight: 650;
      letter-spacing:.2px;
    }
    button.primary{
      background: rgba(120,200,255,.18);
      border-color: rgba(120,200,255,.30);
    }
    .stats{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      color: var(--muted);
      font-size: 13px;
    }
    .pill{
      border: 1px solid var(--stroke);
      background: rgba(255,255,255,.06);
      padding: 7px 10px;
      border-radius: 999px;
    }
    .stage{
      flex: 1;
      display:flex;
      align-items:center;
      justify-content:center;
      min-height: 240px;
    }
    canvas{
      width: 100%;
      height: 100%;
      max-width: 740px;
      max-height: 740px;
      touch-action: manipulation;
    }
    footer{
      text-align:center;
      color: rgba(255,255,255,.55);
      font-size: 12px;
      padding: 6px 0 2px;
    }

    /* Modal */
    .modalBackdrop{
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,.55);
      display:none;
      align-items:center;
      justify-content:center;
      padding: 24px;
    }
    .modal{
      width: min(420px, 100%);
      background: rgba(18,24,46,.92);
      border: 1px solid rgba(255,255,255,.18);
      border-radius: 22px;
      padding: 18px;
      box-shadow: 0 25px 60px rgba(0,0,0,.35);
      backdrop-filter: blur(10px);
    }
    .modal h2{ margin: 0 0 6px; font-size: 20px; }
    .modal p{ margin: 0 0 14px; color: var(--muted); font-size: 14px; }
    .modal .row{
      display:flex;
      gap: 10px;
      justify-content:flex-end;
    }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <div class="top">
        <div class="title">
          <h1>Zero-Sum Swap Puzzle</h1>
          <p>Tap a tile, then tap an adjacent tile to swap. Make every row and column sum to <b>0</b>.</p>
        </div>
        <div class="controls">
          <button id="easyBtn" class="primary">Easy</button>
          <button id="medBtn">Medium</button>
          <button id="hardBtn">Hard</button>
          <button id="newBtn">New Puzzle</button>
        </div>
      </div>

      <div class="stats">
        <div class="pill">Mode: <span id="modeLabel">Easy</span></div>
        <div class="pill">Grid: <span id="sizeLabel">3Ã—3</span></div>
        <div class="pill">Range: <span id="rangeLabel">âˆ’1..+1</span></div>
        <div class="pill">Moves: <span id="movesLabel">0</span></div>
      </div>
    </header>

    <div class="stage">
      <canvas id="board" aria-label="Puzzle board"></canvas>
    </div>

    <footer>Â© 2025</footer>
  </div>

  <div id="modalBackdrop" class="modalBackdrop" role="dialog" aria-modal="true">
    <div class="modal">
      <h2>ðŸŽ‰ You win!</h2>
      <p id="winText">All rows and columns sum to zero.</p>
      <div class="row">
        <button id="closeModalBtn">Close</button>
        <button id="playAgainBtn" class="primary">Play again</button>
      </div>
    </div>
  </div>

<script>
(() => {
  // Modes: (N, maxAbs, scramble swaps)
  const MODES = {
    easy:   { name:"Easy",   N:3, maxAbs:1, shuffle: 90  },
    medium: { name:"Medium", N:4, maxAbs:2, shuffle: 220 },
    hard:   { name:"Hard",   N:4, maxAbs:4, shuffle: 280 },
  };

  let modeKey = "easy";
  let N = MODES[modeKey].N;
  let maxAbs = MODES[modeKey].maxAbs;

  let board = [];
  let moves = 0;
  let selected = null; // {r,c}
  let busy = false;

  // DOM
  const canvas = document.getElementById("board");
  const ctx = canvas.getContext("2d");

  const modeLabel = document.getElementById("modeLabel");
  const sizeLabel = document.getElementById("sizeLabel");
  const rangeLabel = document.getElementById("rangeLabel");
  const movesLabel = document.getElementById("movesLabel");

  const easyBtn = document.getElementById("easyBtn");
  const medBtn  = document.getElementById("medBtn");
  const hardBtn = document.getElementById("hardBtn");
  const newBtn  = document.getElementById("newBtn");

  const modalBackdrop = document.getElementById("modalBackdrop");
  const winText = document.getElementById("winText");
  const closeModalBtn = document.getElementById("closeModalBtn");
  const playAgainBtn = document.getElementById("playAgainBtn");

  // Layout computed each draw
  let layout = null;

  // ---------- Utilities ----------
  const randPick = (arr) => arr[Math.floor(Math.random() * arr.length)];

  function allowedValues() {
    const vals = [];
    for (let v = -maxAbs; v <= maxAbs; v++) vals.push(v);
    return vals;
  }
  function inRange(v) { return Math.abs(v) <= maxAbs; }

  function computeRowSums(b) {
    return b.map(row => row.reduce((a,v)=>a+v,0));
  }
  function computeColSums(b) {
    const sums = Array.from({length: b.length}, () => 0);
    for (let r=0; r<b.length; r++) for (let c=0; c<b.length; c++) sums[c] += b[r][c];
    return sums;
  }
  function isWin(b) {
    const rs = computeRowSums(b);
    const cs = computeColSums(b);
    return rs.every(x => x === 0) && cs.every(x => x === 0);
  }
  function valueText(v){
    return v > 0 ? `+${v}` : String(v);
  }
  function clamp(n, lo, hi){ return Math.max(lo, Math.min(hi, n)); }

  // ---------- Solved board generator (guaranteed valid) ----------
  function generateSolvedBoard() {
    const choices = allowedValues();
    for (let attempt=0; attempt<15000; attempt++) {
      const b = Array.from({length:N}, () => Array.from({length:N}, () => 0));

      // Fill (N-1)x(N-1)
      for (let r=0; r<N-1; r++) {
        for (let c=0; c<N-1; c++) b[r][c] = randPick(choices);
      }

      // last column to fix row sums
      let ok = true;
      for (let r=0; r<N-1; r++) {
        const s = b[r].slice(0, N-1).reduce((a,v)=>a+v,0);
        const need = -s;
        if (!inRange(need)) { ok = false; break; }
        b[r][N-1] = need;
      }
      if (!ok) continue;

      // last row to fix col sums
      for (let c=0; c<N-1; c++) {
        let s = 0;
        for (let r=0; r<N-1; r++) s += b[r][c];
        const need = -s;
        if (!inRange(need)) { ok = false; break; }
        b[N-1][c] = need;
      }
      if (!ok) continue;

      // bottom-right must satisfy both
      let colSumLast = 0;
      for (let r=0; r<N-1; r++) colSumLast += b[r][N-1];
      const needFromCol = -colSumLast;

      let rowSumLast = 0;
      for (let c=0; c<N-1; c++) rowSumLast += b[N-1][c];
      const needFromRow = -rowSumLast;

      if (needFromCol !== needFromRow) continue;
      if (!inRange(needFromCol)) continue;

      b[N-1][N-1] = needFromCol;

      if (b.flat().every(v => v === 0)) continue;
      if (isWin(b)) return b;
    }

    // Fallback patterns
    if (N === 3) return [[1,0,-1],[-1,1,0],[0,-1,1]];
    if (maxAbs >= 4) return [[4,0,-4,0],[0,4,0,-4],[-4,0,4,0],[0,-4,0,4]];
    return [[2,0,-2,0],[0,2,0,-2],[-2,0,2,0],[0,-2,0,2]];
  }

  // Shuffle using adjacent swaps so solvable
  function shuffleFromSolved(solved, swapsCount) {
    const b = solved.map(row => row.slice());
    const dirs = [{dr:1,dc:0},{dr:-1,dc:0},{dr:0,dc:1},{dr:0,dc:-1}];

    function swapCells(r1,c1,r2,c2){
      const t = b[r1][c1];
      b[r1][c1] = b[r2][c2];
      b[r2][c2] = t;
    }

    for (let k=0; k<swapsCount; k++){
      const r = Math.floor(Math.random()*N);
      const c = Math.floor(Math.random()*N);
      const d = randPick(dirs);
      const r2 = r + d.dr, c2 = c + d.dc;
      if (r2<0 || r2>=N || c2<0 || c2>=N) continue;
      swapCells(r,c,r2,c2);
    }

    if (isWin(b)) return shuffleFromSolved(solved, swapsCount + N*N);
    return b;
  }

  // ---------- Canvas sizing & layout ----------
  function resizeCanvas() {
    // Canvas element is sized via CSS to available stage, so measure it
    const rect = canvas.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    canvas.width = Math.max(1, Math.floor(rect.width * dpr));
    canvas.height = Math.max(1, Math.floor(rect.height * dpr));
    ctx.setTransform(dpr,0,0,dpr,0,0); // draw in CSS pixels
    computeLayout();
    draw();
  }

  function computeLayout(){
    const w = canvas.getBoundingClientRect().width;
    const h = canvas.getBoundingClientRect().height;

    // We draw (N tiles) plus one sums column on the right and one sums row on the bottom.
    const cols = N + 1;
    const rows = N + 1;

    // Padding around board inside canvas
    const pad = 10;
    const usableW = w - pad*2;
    const usableH = h - pad*2;

    // gap between cells
    const gap = (N === 4) ? 4 : 6;

    // compute cell size to fit both dimensions
    const cellW = (usableW - gap*(cols-1)) / cols;
    const cellH = (usableH - gap*(rows-1)) / rows;
    const cell = Math.floor(Math.min(cellW, cellH));

    // center board
    const boardW = cell*cols + gap*(cols-1);
    const boardH = cell*rows + gap*(rows-1);
    const x0 = Math.floor((w - boardW)/2);
    const y0 = Math.floor((h - boardH)/2);

    layout = { w, h, pad, gap, cell, x0, y0, cols, rows, boardW, boardH };
  }

  function cellRect(col, row){
    const {x0,y0,cell,gap} = layout;
    const x = x0 + col*(cell+gap);
    const y = y0 + row*(cell+gap);
    return {x,y,w:cell,h:cell};
  }

  function pointToTile(px, py){
    // tiles are in cols [0..N-1], rows [0..N-1]
    if (!layout) return null;
    for (let r=0; r<N; r++){
      for (let c=0; c<N; c++){
        const rect = cellRect(c, r);
        if (px >= rect.x && px <= rect.x + rect.w && py >= rect.y && py <= rect.y + rect.h){
          return {r,c};
        }
      }
    }
    return null;
  }

  // ---------- Drawing ----------
  function drawRoundedRect(x,y,w,h,r){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr, y);
    ctx.arcTo(x+w, y, x+w, y+h, rr);
    ctx.arcTo(x+w, y+h, x, y+h, rr);
    ctx.arcTo(x, y+h, x, y, rr);
    ctx.arcTo(x, y, x+w, y, rr);
    ctx.closePath();
  }

  function tileFillFor(v){
    // Very simple: dark tile with slight tint by sign
    if (v < 0) return "rgba(255,160,160,0.18)";
    if (v > 0) return "rgba(170,255,190,0.18)";
    return "rgba(255,255,255,0.12)";
  }
  function tileTextFor(v){
    if (v < 0) return "rgba(255,170,170,.95)";
    if (v > 0) return "rgba(190,255,210,.95)";
    return "rgba(255,255,255,.92)";
  }
  function sumFill(ok){
    return ok ? "rgba(170,255,190,0.10)" : "rgba(255,160,160,0.10)";
  }
  function sumText(ok){
    return ok ? "rgba(190,255,210,.95)" : "rgba(255,170,170,.95)";
  }

  function draw(){
    if (!layout) computeLayout();
    const {w,h,cell} = layout;

    // Clear
    ctx.clearRect(0,0,w,h);

    // Compute sums
    const rowSums = computeRowSums(board);
    const colSums = computeColSums(board);

    // Draw tiles
    const radius = Math.max(6, Math.floor(cell*0.20));
    const fontSize = clamp(Math.floor(cell*0.38), 11, 22);
    const sumFont = clamp(Math.floor(cell*0.30), 10, 18);

    // Tiles
    for (let r=0; r<N; r++){
      for (let c=0; c<N; c++){
        const rect = cellRect(c, r);
        // tile fill
        ctx.fillStyle = tileFillFor(board[r][c]);
        drawRoundedRect(rect.x, rect.y, rect.w, rect.h, radius);
        ctx.fill();

        // selection highlight
        if (selected && selected.r === r && selected.c === c){
          ctx.strokeStyle = "rgba(120,200,255,.85)";
          ctx.lineWidth = Math.max(2, Math.floor(cell*0.05));
          ctx.stroke();
        }

        // text
        ctx.fillStyle = tileTextFor(board[r][c]);
        ctx.font = `800 ${fontSize}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(valueText(board[r][c]), rect.x + rect.w/2, rect.y + rect.h/2);
      }
    }

    // Row sums on right (col = N, rows 0..N-1)
    for (let r=0; r<N; r++){
      const rect = cellRect(N, r);
      const ok = rowSums[r] === 0;
      ctx.fillStyle = sumFill(ok);
      drawRoundedRect(rect.x, rect.y, rect.w, rect.h, radius);
      ctx.fill();
      ctx.fillStyle = sumText(ok);
      ctx.font = `850 ${sumFont}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(String(rowSums[r]), rect.x + rect.w/2, rect.y + rect.h/2);
    }

    // Column sums on bottom (row = N, cols 0..N-1)
    for (let c=0; c<N; c++){
      const rect = cellRect(c, N);
      const ok = colSums[c] === 0;
      ctx.fillStyle = sumFill(ok);
      drawRoundedRect(rect.x, rect.y, rect.w, rect.h, radius);
      ctx.fill();
      ctx.fillStyle = sumText(ok);
      ctx.font = `850 ${sumFont}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(String(colSums[c]), rect.x + rect.w/2, rect.y + rect.h/2);
    }

    // Corner Î£
    {
      const rect = cellRect(N, N);
      ctx.fillStyle = "rgba(255,255,255,0.06)";
      drawRoundedRect(rect.x, rect.y, rect.w, rect.h, radius);
      ctx.fill();
      ctx.fillStyle = "rgba(255,255,255,0.45)";
      ctx.font = `900 ${clamp(Math.floor(cell*0.28), 10, 16)}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText("Î£", rect.x + rect.w/2, rect.y + rect.h/2);
    }

    // Update UI labels
    movesLabel.textContent = String(moves);
    sizeLabel.textContent = `${N}Ã—${N}`;
    modeLabel.textContent = MODES[modeKey].name;
    rangeLabel.textContent = `âˆ’${maxAbs}..+${maxAbs}`;
  }

  // ---------- Interaction ----------
  function isAdjacent(a,b){
    return (Math.abs(a.r-b.r) + Math.abs(a.c-b.c)) === 1;
  }

  function swapCells(a,b){
    const t = board[a.r][a.c];
    board[a.r][a.c] = board[b.r][b.c];
    board[b.r][b.c] = t;
  }

  function handleTap(clientX, clientY){
    if (busy) return;
    const rect = canvas.getBoundingClientRect();
    const x = clientX - rect.left;
    const y = clientY - rect.top;

    const tile = pointToTile(x, y);
    if (!tile) {
      selected = null;
      draw();
      return;
    }

    if (!selected){
      selected = tile;
      draw();
      return;
    }

    // tap same tile -> deselect
    if (selected.r === tile.r && selected.c === tile.c){
      selected = null;
      draw();
      return;
    }

    // adjacent -> animate swap
    if (isAdjacent(selected, tile)){
      busy = true;
      const a = selected;
      const b = tile;
      selected = null;

      // simple animation: interpolate positions for the two tiles
      const start = performance.now();
      const dur = 160;

      const aRect0 = cellRect(a.c, a.r);
      const bRect0 = cellRect(b.c, b.r);

      const aVal = board[a.r][a.c];
      const bVal = board[b.r][b.c];

      function frame(now){
        const t = clamp((now - start)/dur, 0, 1);
        // ease
        const e = 1 - Math.pow(1 - t, 3);

        // redraw base board without the two tiles (draw tiles as blanks)
        const savedA = board[a.r][a.c];
        const savedB = board[b.r][b.c];
        board[a.r][a.c] = 0;
        board[b.r][b.c] = 0;
        draw();
        board[a.r][a.c] = savedA;
        board[b.r][b.c] = savedB;

        // draw moving tiles
        const dx = (bRect0.x - aRect0.x);
        const dy = (bRect0.y - aRect0.y);

        const cell = layout.cell;
        const radius = Math.max(6, Math.floor(cell*0.20));
        const fontSize = clamp(Math.floor(cell*0.38), 11, 22);

        // A moves toward B
        const ax = aRect0.x + dx*e;
        const ay = aRect0.y + dy*e;
        ctx.fillStyle = tileFillFor(aVal);
        drawRoundedRect(ax, ay, aRect0.w, aRect0.h, radius);
        ctx.fill();
        ctx.fillStyle = tileTextFor(aVal);
        ctx.font = `800 ${fontSize}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
        ctx.textAlign="center"; ctx.textBaseline="middle";
        ctx.fillText(valueText(aVal), ax+aRect0.w/2, ay+aRect0.h/2);

        // B moves toward A
        const bx = bRect0.x - dx*e;
        const by = bRect0.y - dy*e;
        ctx.fillStyle = tileFillFor(bVal);
        drawRoundedRect(bx, by, bRect0.w, bRect0.h, radius);
        ctx.fill();
        ctx.fillStyle = tileTextFor(bVal);
        ctx.font = `800 ${fontSize}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
        ctx.fillText(valueText(bVal), bx+bRect0.w/2, by+bRect0.h/2);

        if (t < 1){
          requestAnimationFrame(frame);
        } else {
          // commit swap
          swapCells(a,b);
          moves += 1;
          busy = false;
          draw();
          if (isWin(board)) showWinModal();
        }
      }

      requestAnimationFrame(frame);
      return;
    }

    // not adjacent -> change selection
    selected = tile;
    draw();
  }

  canvas.addEventListener("pointerdown", (e) => {
    // prevent page scrolling when tapping board
    e.preventDefault();
    handleTap(e.clientX, e.clientY);
  }, {passive:false});

  // ---------- Modal ----------
  function showWinModal(){
    winText.textContent = `Solved! Moves: ${moves}.`;
    modalBackdrop.style.display = "flex";
  }
  function hideWinModal(){
    modalBackdrop.style.display = "none";
  }
  closeModalBtn.addEventListener("click", hideWinModal);
  playAgainBtn.addEventListener("click", () => { hideWinModal(); newGame(); });
  modalBackdrop.addEventListener("click", (e) => { if (e.target === modalBackdrop) hideWinModal(); });

  // ---------- Game control ----------
  function setMode(key){
    modeKey = key;
    N = MODES[modeKey].N;
    maxAbs = MODES[modeKey].maxAbs;

    easyBtn.classList.toggle("primary", modeKey === "easy");
    medBtn.classList.toggle("primary", modeKey === "medium");
    hardBtn.classList.toggle("primary", modeKey === "hard");

    newGame();
  }

  function newGame(){
    hideWinModal();
    moves = 0;
    selected = null;
    busy = false;

    const solved = generateSolvedBoard();
    board = shuffleFromSolved(solved, MODES[modeKey].shuffle);

    draw();
  }

  easyBtn.addEventListener("click", () => setMode("easy"));
  medBtn.addEventListener("click",  () => setMode("medium"));
  hardBtn.addEventListener("click", () => setMode("hard"));
  newBtn.addEventListener("click", newGame);

  // Resize handling
  window.addEventListener("resize", resizeCanvas);
  window.addEventListener("orientationchange", resizeCanvas);

  // Boot
  setMode("easy");
  // defer resize until layout settled
  requestAnimationFrame(resizeCanvas);
})();
</script>
</body>
</html>




